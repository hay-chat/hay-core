import { TRPCError } from "@trpc/server";
import { t } from "@server/trpc/init";
import * as jwt from "jsonwebtoken";
import type { Context } from "@server/trpc/context";
import { config } from "@server/config/env";

/**
 * Plugin JWT token payload
 */
interface PluginTokenPayload {
  organizationId: string;
  pluginId: string;
  scope: string;
  capabilities: string[];
  iat: number;
  exp: number;
}

/**
 * Extended context with plugin authentication
 */
export interface PluginAuthContext extends Context {
  pluginAuth: {
    organizationId: string;
    pluginId: string;
    capabilities: string[];
  };
}

/**
 * Middleware to verify plugin JWT token
 *
 * Plugins authenticate using JWT tokens generated by the plugin manager.
 * The token contains:
 * - organizationId: Organization ID this plugin instance belongs to
 * - pluginId: Plugin identifier
 * - scope: Must be "plugin-api"
 * - capabilities: Array of capabilities (routes, messages, customers, sources, mcp)
 */
export const verifyPluginAuth = t.middleware(async ({ ctx, next }) => {
  // Extract token from Authorization header
  const authHeader = ctx.req.headers.authorization;

  if (!authHeader) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "No authorization header provided",
    });
  }

  const token = authHeader.replace("Bearer ", "");

  if (!token) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "No token provided",
    });
  }

  try {
    // Verify JWT token
    const decoded = jwt.verify(token, config.jwt.secret) as PluginTokenPayload;

    // Verify scope
    if (decoded.scope !== "plugin-api") {
      throw new TRPCError({
        code: "FORBIDDEN",
        message: "Invalid token scope",
      });
    }

    // Verify required fields
    if (!decoded.organizationId || !decoded.pluginId || !decoded.capabilities) {
      throw new TRPCError({
        code: "FORBIDDEN",
        message: "Invalid token payload",
      });
    }

    // Add plugin auth to context
    return await next({
      ctx: {
        ...ctx,
        pluginAuth: {
          organizationId: decoded.organizationId,
          pluginId: decoded.pluginId,
          capabilities: decoded.capabilities,
        },
      } as PluginAuthContext,
    });
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Token has expired",
      });
    }

    if (error instanceof jwt.JsonWebTokenError) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Invalid token",
      });
    }

    // Re-throw TRPC errors
    if (error instanceof TRPCError) {
      throw error;
    }

    throw new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      message: "Failed to verify token",
    });
  }
});

/**
 * Plugin procedure with authentication
 */
export const pluginProcedure = t.procedure.use(verifyPluginAuth);

/**
 * Helper to check if a capability is present
 */
export function requireCapability(ctx: PluginAuthContext, capability: string): void {
  if (!ctx.pluginAuth.capabilities.includes(capability)) {
    throw new TRPCError({
      code: "FORBIDDEN",
      message: `Plugin does not have '${capability}' capability`,
    });
  }
}
